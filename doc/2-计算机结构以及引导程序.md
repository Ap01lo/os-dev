## 第二章 计算机结构以及引导程序

### 2.1 启动过程

现在，我们要开始我们的旅程了：

当我们重启电脑时，机器必须完完全全重新启动，开始时没有任何操作系统的概念在其中。然后，机器需要从一个稳定长久的存储设备中继续加载操作系统，当然也可能是别的什么东西，这些存储设备需要连接到计算机（比如软盘，硬盘，USB盘等等）。

我们很快就会发现，我们所用的电脑为我们的操作系统所提供的预加载环境提供了很少的服务：在这个阶段，我们想要一个基本的文件系统甚至都是奢侈的，我们根本无法使用他们。但是所幸，我们有BIOS(Basic input output system)，这是一个软件的例行程序的集合，这些例行程序在计算机开机加电的时候被从内存中加载到硬盘，并且初始化。BIOS系统提供了自检测服务和计算机重要设备的及嫩管理程序，比如屏幕，键盘，硬盘等等。

在BIOS完成一些基本的硬件检测之后（特别是装载的内存区域工作是否正常），他就要引导存放在某个设备上的操作系统了。在这里我们需要记住，虽然但是，BIOS不能只简单的加载一个代表操作系统的文件然后拿来启动，因为BIOS还没有文件系统的概念。BIOS必须要读取磁盘上的某个特定扇区的数据（通常为512byte大小），比如第3个柱面，第2个磁道，第5个扇区。

因此，对于BIOS来说，找到OS存放位置的最简单的地方就是一个磁盘的第一个扇区（第0柱面，第0磁道，第0扇区），也就是我们所熟知的引导扇区。因为不是所有的磁盘上都有操作系统，所以BIOS必须搞清楚哪些磁盘的引导扇区是可执行的引导程序，哪些磁盘的引导扇区里只是简单的数据。需要注意的是，cpu在执行指令的时候，不能区分什么是可执行程序，什么是数据，一切二进制数据都可以被翻译为指令。

在这里，一个看起来没什么道理的方式被BIOS采纳了，一个将要被执行的引导扇区的最后两个字节的内容必须是魔法数字 `0xaa55`。由此，BIOS系统就可以在每个存储里循环检索，将可用的引导扇区的内容加载到内存中，然后指示cpu开始执行它所找到的以那个魔法数字结尾的第一个引导扇区。

### 2.2 BIOS, 引导块，以及魔法数字

如果我们使用可以编辑二进制的编辑器，我们就可以将原始的二进制值写入文件，这不像传统的文本编辑器，二进制编辑器会将字符转化成ASCII码的值，因此我们可以自己创造一个简单有效的引导区块。

```context
图 2.1 一个用16进制写成的机器码引导区块

e9 fd ff 00 00 00 00 00 00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
* * *
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa
(一共512字节)
```

 可以注意到，在图2.1中，有三个重要特征：

+ 开始的三个字节，用十六进制写成的 `0xe9,0xfd 和 0xff` 实际上是机器码形式的指令，由cpu出厂定义，进行无休止的跳跃

+ 最后两个字节 `0x55 0xaa` 构成了魔法数字，用来告诉BIOS，这个区块就是一个实打实的引导区块，而不是一个碰巧存到引导区块的数据

+ 整个部分被 `0` 占据并填充到512字节，用来让BIOS定位并识别在区块最后面的魔法数字

有一个字节顺序方面的重要问题。你可能想知道，我们之前说过BIOS的魔法数字是 `0xaa55` 但是在我们的引导区块里面，他被写作连续的 `0x55 0xaa` 。这是因为x86结构采用小端存储的方式来存储多字节的数据，这种方式会先处理此重要的数据，在处理更重要的数据，这与我们平常熟悉的数字系统不同。

编译器和汇编器可以通过我们自定义的数据结构隐藏很多数据顺序的问题，比如，一个16进制的数据可以自动的序列化成具有正确顺序的机器码。有时这个非常有用，特别是在找bug的时候，可以精确的知道哪个字节要被存储到设备中，因此对字节顺序的处理很重要。

这个可能是我们的电脑能运行的最小的程序了，但是他依然是有效的，我们可以用两种方式来测试他，其中的第二种方式比较安全，更加适合我们的实际情况：

+ 使用随便什么你的操作系统支持的方式，将这个引导块写入一个不重要的磁盘的第一个扇区中，然后重启电脑

+ 使用虚拟软件，例如VMware和VirtureBox，然后将引导块设置为一个磁盘镜像，然后启动虚拟机。

如果你的电脑在重启后只是挂起，而没有提示 **未找到操作系统** 之类的消息，那么就可以确定，引导程序已经被加载并且执行了。这是一个无限循环的操作，我们将他放在了所有程序的第一个。如果没有这个循环，CPU就会继续前进，执行接下来内存中每一个二进制指令，然而接下来的指令大多都是随机的，没有初始化的字节，直到它陷入了一些无效状态，重启或者碰巧执行了BIOS程序，格式化了你的主硬盘。

记住，是我们在编程控制电脑，电脑只能盲目的遵照我们的指示获取指令并执行他们，直到关机。所以我们要确认，电脑执行的是我们创造的指令，而不是在内存中随便一个地方存储的不知道什么东西的数据。在这个较低的层次，我们对电脑有掌控能力，并且也有相应责任，因此我们需要去学习如何控制它。

### 2.3 CPU模拟器

有一个第三方，而且更简单的方式来测试这些底层的程序，不需要反复连续的重启机器和不停在硬盘上删除数据，那就是使用一个cpu模拟器，比如Bochs和qemu。不同于对真机的模拟，需要优化性能而使用真实的cpu对指令进行运行，cpu模拟只需要使用不同的变量来代表cpu内部的不同寄存器，使用高级语言来模拟底层操作，因此速度比较慢，但是非常适合开发和调试类似的系统。

需要注意的是，为了在模拟器上做一些有意义的事情，我们需要给模拟器一些磁盘映像形式的代码来运行。一个映像文件就是简单被写在磁盘媒介上的原始数据（包括机器码和数据），比如CD，USB存储器等等。事实上，一些模拟器可以成功运行从CD上下载或者提取出来的操作系统，因此虚拟化，比较适合这种用法。

模拟器可以将底层的显示设备指令翻译成可以渲染在桌面屏幕的像素点，以便让我们看见我们的指令在真实的屏幕上会显示什么。

因此总的来说，对于我们这篇文章里面的练习代码，能在模拟器上成功运行的也能在真机上运行，不过真机速度更快罢了。

#### 2.3.1 Bochs ：一个x86 cpu 模拟器

`Bochs` 需要我们编写一个简单的配置文件 ：*bochsrc* , 这个文件存在于本地，它描述了我们想要如何模拟真机的一些参数，以及比较重要的，程序运行时哪个软盘映像要被引导加载。

图2.2显示了一个Bochs的样例配置文件，我们可以用来测试引导扇区，文件保存为 `boot_sect.bin`。

```context
图2.2

# 告诉 bochs 使用我们自己定义的引导代码，将其作为一个插入进电脑的软盘

floppya: 1_44=boot_sect.bin, status=inserted
boot: a
```

如果要在bochs里面测试引导扇区，只需要输入：

```shell
$ bochs
```

做一个小实验，试试改变BIOS的魔法数字，将他变成一个随机的数字然后重启bochs。

因为bochs的模拟接近真实的cpu，所以你在bochs测试完成之后，一定能够在真机上引导成功，而且会更快。

#### 2.3.2 Qemu

Qemu跟bochs很像，而且更加的轻便和有效。因为Qemu不需要bochs那么多的文档配置，所以这也意味着它更加的容易上手，只需要输入：

```shell
qemu <your-os-boot-disk-image-file>
```



### 2.4 十六进制符号的使用

我们已经见到过很多十六进制数字的例子了，因此理解为什么要在底层编程中使用十六进制时十分重要的。

首先我们想想为什么我们数到十的时候更自然，因为当我们看见十六进制的时候总是会去想为什么不数到十呢？我不是这方面的专家，但是我猜想，这与我们生来就有十根手指头有关系，这导致了我们会用十个不同的符号来表示数字：0,1,2,3,4,5,6,7,8,9

十进制是以十为基础的（有十个不同的符号），但是十六进制以十六为基础，所以我们不得不发明一些新的数字符号，一种比较简单的方式就是直接用一些字母来表示：0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f,比如，其中的d可以表示数字13。

为了区分十六进制与其他的数字系统，我们通常使用前缀`0x` ，有时候也使用后缀 `h` 来表示十六进制，这对于那些碰巧没有带字母的十六进制数字非常重要，比如 `0x50` 和 `50`不相等， `0x50` 是十六进制，代表十进制中的`80`。

电脑将一个数字表示成一系列的比特位（二进制数字），由此，计算机基本的底层电路就可以识别两种基本的电子状态：0和1，就像电脑有两个手指头一样。因此，为了表示大于1的数字，电脑就需要扩展比特位的位数，就像我们数大于9的数字时，会用更多的数字位数来表示。

我们使用一些名称来表示特定位数的比特数字，以便我们平时的讨论交流以及在处理问题时对比特位数的统一。绝大多数电脑的指令能处理的最小位数是8bit，我们称之为`byte（字节）`，当然还有其他的长度比如`short,int long` 分别代表`16-bit, 32-bit, 64-bit`的值。我们同样会使用`word` 这种表达方式，这用来表示我们当前cpu所在模式能处理的最大位数：在16-bit实模式下， 一个`word`就代表16-bit，在 32-bit 的保护模式下，一个`word`就代表32-bit，以此类推。

所以，我们回到16进制的好处上来：一串比特位写起来很麻烦，但是我们可以很轻易的将其转换成为更短更方便的十六进制符号，这比转换成十进制容易的多，这是因为我们可以将比特位按照四位划分开来，而不是将一长串放在一起，如果这样的话，我们要数更大的数字时就更加困难了，比如16，32，64等等。


