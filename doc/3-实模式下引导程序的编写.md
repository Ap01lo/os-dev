## 第三章 实模式下引导程序的编写

尽管有了实例代码，我相信让你用二进制编辑器写二进制代码的时候你依然很懵逼。你必须记住，或者要经常的查阅哪些机器码会让cpu做哪些事情。但幸运的是，你并不孤单，我们发明了汇编器，它可以将我们易用的代码翻译成针对某种特定cpu的机器指令。

在这一章节里，我们将会深入研究一些越来越复杂的引导扇区的代码，以便熟悉汇编过程和将要运行我们程序的简陋的操作系统预环境。

### 3.1 重温引导扇区

现在，我们要重新创建用二进制编辑器编写的引导程序，而不使用汇编代码，这样我们就可以清楚的看到底层语言的值了。

我们可以使用如下命令将其汇编成真实的机器码（一串计算机可以翻译成指令的字节数字）：

```
$ nasm boot_sect.asm -f bin -o boot_sect.bin
```

其中， `boot_sect.asm` 是我们在图3.1写的源码保存下来的文件， `boot_sect.bin` 是我们可以加载到磁盘引导扇区的汇编好的机器码。

注意，我们使用了 `-f bin` 参数来指示nasm生成原始的机器码，而不是我们在更复杂操作系统环境中可能会使用的带有其他元链接信息的代码包。我们并不需要这些累赘代码。除了更底层的bios代码之外，我们现在是机器上能跑的唯一程序的了。我们现在就是一个操作系统，尽管我们现在除了提供一个无尽循环之外、什么也干不了，但我们将会从这里开始一点一点搭建。

```nasm
图 3.1 一个用汇编语言写的简单引导程序

;
;    一个无限循环的引导程序
;

; 定义一个loop地址，以便我们可以跳转
loop:

    ; 使用简单的cpu指令，可以跳转到新的地址继续执行。
    ; 在我们的例子中，我们跳转至我们当前所执行的指令
    jmp loop                     ; 

; 当编译的时候，我们的程序必须是512字节
; 而且最后两字节必须是魔法数字
; 因此这里，我们告诉汇编器，用零填充剩余的字节直到510字节
times 510-($-$$) db 0

; 剩下的两个字节填充魔法数字
; 此时，BIOS 可以识别出来，我们是引导扇区了
dw 0xaa55
```

不需要将程序写入软盘或者硬盘，我们通过运行bochs就可以测试程序：

```shell
$ bochs
```

或者，根据喜好以及模拟器的功能，我们可以使用qemu：

```shell
qemu boot_set.bin
```

当然，你也可以将映像文件加载到虚拟机上或者写入一些可以承载引导程序的媒介上去。但是要注意，当你将印象文件写入一些媒介中时，并不代表你将程序写到了该媒介的文件系统中去，你需要使用一些合适的工具将其直接写入引导区块。

如果想更简单直接的看到汇编器到底生成了什么，我们可以运行下面的程序将二进制变为可观的十六进制：

```shell
$ od -t x1 -A n boot_sect.bin
```

这个命令的输出结果你一定很熟悉。

恭喜了，你已经成功使用汇编语言写了一个引导程序了。对于所有的操作系统，他们都需要用这种方式来启动，然后一步一步走到更高更抽象的层级（使用高级语言，比如C, C++）



### 3.2 16-bit 实模式

CPU的生产厂家必须大费周折的让他们的cpu和以前的cpu相兼容，以便那些老旧的程序和操作系统可以在现在的最新cpu上运行。

由Intel实施的解决方案和那些兼容的cpu其实就是去模拟atsyige体系里的那些老cpu：Intel 8086cpu，他支持16-bit的指令，但是并没有内存保护的概念。内存保护对于现在操作系统的稳定性非常重要。，它可以限制用户程序的随意接入、表达以及对内核的存储，这些操作无论时有意还是无意，都可能会规避系统的安全机制或者甚至上整个系统宕机。

所以，为了向后兼容，cpu在启动引导的时候使用16-bit的实模式时很重要的，它可以让现代操作系统转到更高级的保护模式（32-bit或者64-bit），也可以让老旧的操作系统完美加载，而不让他们直到自己正运行在一个更高级的cpu上。一会，我们将要仔细研究这个从16-bit实模式到32-bit保护模式转换过程的细节。

总而言之，当我们说这个cpu是16-bit的时候，这意味着他的指令一次只能处理最大16位的运算。举个例子，一个16-bit的cpu有一个指令可以在一个cpu周期内运算两个16-bit数字的加法，但是如果我们需要计算两个32-bit的数字加法，就需要用16-bit的加法指令花费更多的cpu周期进行运算。

首先，我们先探索一下16-bit实模式环境，因为所有操作系统都是从这里开始的，然后我们再看看如何转换成32-bit保护模式，以及这样的主要好处。



### 3.3 Hello

现在，我们将要写一个简单的引导程序，可以在屏幕上显示一些信息。要做到这个，我们首先要学习一下cpu工作的基础知识以及我们应该如何借助BIOS来控制屏幕设备。

首先，我们得想想我们应该做些什么。我们想要在屏幕上输出字符，但是我们还不知道如何跟显示设备交互，因为可能会有很多种类的显示器，并且他们各自还会有不同的接口。因此我们需要BIOS，因为BIOS已经做了一些对硬件的自动检测，而且事实上，我们可以看到BIOS已经成功在屏幕上输出了一些自检相关的信息，所以它可以帮助我们。

所以接下来，我们要让BIOS在屏幕上为我们输出字符，但是如何让BIOS做的这一点呢？这里没有JAVA的库函数可以用，现在的阶段是不可能的。但是我们可以确定，在存储设备的面个位置，一定存在着一些BOIS指令的机器码，这些机器码可以帮助我们在屏幕上输出。但是实际上，想要找到这些BOIS代码并且执行是非常麻烦的，而且很有可能会报错，因为在不同的机器上，BIOS的内部代码也会有所不同。

在这里，我们会使用一个计算机的基本功能：中断。

#### 3.3.1 中断

中断是一个计算机内部的机制，它允许cpu可以暂时的停下正在做的任务，而去做一些其他的更高优先级的任务，之后再返回原任务。一个中断可以被软件指令引起，也可以被一些需要更高优先级操作的硬件设备发起（比如从网络设备中读取输入数据）。

每一种中断都由一个单独的数字符号所表示，这些数字同时也是中断向量表的索引，中断向量表由BIOS在物理内存最开始的地方建立（0x0），包含了指向各种中断服务程序（ISR）的指针，一个ISR实际上是一系列的机器指令集合，就像我们的引导程序一样，用来处理一个特定的中断（比如从硬盘或者网卡中读取数据）。

所以，简而言之，BIOS会将自己的一些ISR添加到中断向量表中去，这些ISR会负责计算机的某个方面，比如：中断号为 `0x10`的中断可以调用屏幕显示相关的ISR，中断号为`0x13`的中断可以调用与磁盘相关的ISR。

然而，对于计算机来说，对每个BIOS例程都分配一个中断会比较浪费资源，所以BIOS将这些ISR复用了，通过我们能想通的 `switch`方式，根据常驻在cpu中的一个通用寄存器`ax`的值来确定执行哪个中断。

#### 3.3.2 CPU 寄存器

正如我们在高级语言中使用的变量一样，我们在一个特定的例程中可以短暂的存储数据是非常有用的。所有的 x86 CPU都有四个通用寄存器：`ax,bx,cx,dx` 就是为了实现上述目的。对于每个寄存器，他们都可以存储一个字（两个字节，16 位)的数据，还可以用跟访问主存比起来能够忽略的延迟进行读写。在汇编语言中，一个最常用的操作就是在两个寄存器之间移动数据（或者更精确的叫做复制）：

```nasm
mov ax, 1234     ; 将十进制数 1234 存进ax
mov cx, 0x234    ; 将十六进制数 0x234 存进cx
mov dx, 't'      ; 将 ASCII 字符 't' 村润dx 
mov bx, ax       ; 将ax中的值赋值到bx中，因此现在 bx==1234
```

需要注意，`mov` 操作的目标地址在第一个参数而不是第二个参数，但是这个规律会随着不同的汇编器而不同。

有时，单独操作单字节会更加方便，所以让我们再试试单独设置这些寄存器的高位和低位：

```nasm
mov ax, 0            ; ax -> 0x0000
mov ah, 0x56         ; ax -> 0x5600
mov al, 0x23         ; ax -> ax5623
mov ah, 0x16         ; ax -> ax1623
```

#### 3.3.3 整合在一起
