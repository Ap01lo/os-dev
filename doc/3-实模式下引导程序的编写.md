## 第三章 实模式下引导程序的编写

尽管有了实例代码，我相信让你用二进制编辑器写二进制代码的时候你依然很懵逼。你必须记住，或者要经常的查阅哪些机器码会让cpu做哪些事情。但幸运的是，你并不孤单，我们发明了汇编器，它可以将我们易用的代码翻译成针对某种特定cpu的机器指令。

在这一章节里，我们将会深入研究一些越来越复杂的引导扇区的代码，以便熟悉汇编过程和将要运行我们程序的简陋的操作系统预环境。

### 3.1 重温引导扇区

现在，我们要重新创建用二进制编辑器编写的引导程序，而不使用汇编代码，这样我们就可以清楚的看到底层语言的值了。

我们可以使用如下命令将其汇编成真实的机器码（一串计算机可以翻译成指令的字节数字）：

```
$ nasm boot_sect.asm -f bin -o boot_sect.bin
```

其中， `boot_sect.asm` 是我们在图3.1写的源码保存下来的文件， `boot_sect.bin` 是我们可以加载到磁盘引导扇区的汇编好的机器码。

注意，我们使用了 `-f bin` 参数来指示nasm生成原始的机器码，而不是我们在更复杂操作系统环境中可能会使用的带有其他元链接信息的代码包。我们并不需要这些累赘代码。除了更底层的bios代码之外，我们现在是机器上能跑的唯一程序的了。我们现在就是一个操作系统，尽管我们现在除了提供一个无尽循环之外、什么也干不了，但我们将会从这里开始一点一点搭建。

```nasm
图 3.1 一个用汇编语言写的简单引导程序

;
;    一个无限循环的引导程序
;

; 定义一个loop地址，以便我们可以跳转
loop:

    ; 使用简单的cpu指令，可以跳转到新的地址继续执行。
    ; 在我们的例子中，我们跳转至我们当前所执行的指令
    jmp loop                     ; 

; 当编译的时候，我们的程序必须是512字节
; 而且最后两字节必须是魔法数字
; 因此这里，我们告诉汇编器，用零填充剩余的字节直到510字节
times 510-($-$$) db 0

; 剩下的两个字节填充魔法数字
; 此时，BIOS 可以识别出来，我们是引导扇区了
dw 0xaa55
```

不需要将程序写入软盘或者硬盘，我们通过运行bochs就可以测试程序：

```shell
$ bochs
```

或者，根据喜好以及模拟器的功能，我们可以使用qemu：

```shell
qemu boot_set.bin
```

当然，你也可以将映像文件加载到虚拟机上或者写入一些可以承载引导程序的媒介上去。但是要注意，当你将印象文件写入一些媒介中时，并不代表你将程序写到了该媒介的文件系统中去，你需要使用一些合适的工具将其直接写入引导区块。

如果想更简单直接的看到汇编器到底生成了什么，我们可以运行下面的程序将二进制变为可观的十六进制：

```shell
$ od -t x1 -A n boot_sect.bin
```

这个命令的输出结果你一定很熟悉。

恭喜了，你已经成功使用汇编语言写了一个引导程序了。对于所有的操作系统，他们都需要用这种方式来启动，然后一步一步走到更高更抽象的层级（使用高级语言，比如C, C++）


