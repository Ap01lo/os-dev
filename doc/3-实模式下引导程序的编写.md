## 第三章 实模式下引导程序的编写

尽管有了实例代码，我相信让你用二进制编辑器写二进制代码的时候你依然很懵逼。你必须记住，或者要经常的查阅哪些机器码会让cpu做哪些事情。但幸运的是，你并不孤单，我们发明了汇编器，它可以将我们易用的代码翻译成针对某种特定cpu的机器指令。

在这一章节里，我们将会深入研究一些越来越复杂的引导扇区的代码，以便熟悉汇编过程和将要运行我们程序的简陋的操作系统预环境。

### 3.1 重温引导扇区

现在，我们要重新创建用二进制编辑器编写的引导程序，而不使用汇编代码，这样我们就可以清楚的看到底层语言的值了。

我们可以使用如下命令将其汇编成真实的机器码（一串计算机可以翻译成指令的字节数字）：

```
$ nasm boot_sect.asm -f bin -o boot_sect.bin
```

其中， `boot_sect.asm` 是我们在图3.1写的源码保存下来的文件， `boot_sect.bin` 是我们可以加载到磁盘引导扇区的汇编好的机器码。

注意，我们使用了 `-f bin` 参数来指示nasm生成原始的机器码，而不是我们在更复杂操作系统环境中可能会使用的带有其他元链接信息的代码包。我们并不需要这些累赘代码。除了更底层的bios代码之外，我们现在是机器上能跑的唯一程序的了。我们现在就是一个操作系统，尽管我们现在除了提供一个无尽循环之外、什么也干不了，但我们将会从这里开始一点一点搭建。

```nasm
图 3.1 一个用汇编语言写的简单引导程序

;
;    一个无限循环的引导程序
;

; 定义一个loop地址，以便我们可以跳转
loop:

    ; 使用简单的cpu指令，可以跳转到新的地址继续执行。
    ; 在我们的例子中，我们跳转至我们当前所执行的指令
    jmp loop                     ; 

; 当编译的时候，我们的程序必须是512字节
; 而且最后两字节必须是魔法数字
; 因此这里，我们告诉汇编器，用零填充剩余的字节直到510字节
times 510-($-$$) db 0

; 剩下的两个字节填充魔法数字
; 此时，BIOS 可以识别出来，我们是引导扇区了
dw 0xaa55
```

不需要将程序写入软盘或者硬盘，我们通过运行bochs就可以测试程序：

```shell
$ bochs
```

或者，根据喜好以及模拟器的功能，我们可以使用qemu：

```shell
qemu boot_set.bin
```

当然，你也可以将映像文件加载到虚拟机上或者写入一些可以承载引导程序的媒介上去。但是要注意，当你将印象文件写入一些媒介中时，并不代表你将程序写到了该媒介的文件系统中去，你需要使用一些合适的工具将其直接写入引导区块。

如果想更简单直接的看到汇编器到底生成了什么，我们可以运行下面的程序将二进制变为可观的十六进制：

```shell
$ od -t x1 -A n boot_sect.bin
```

这个命令的输出结果你一定很熟悉。

恭喜了，你已经成功使用汇编语言写了一个引导程序了。对于所有的操作系统，他们都需要用这种方式来启动，然后一步一步走到更高更抽象的层级（使用高级语言，比如C, C++）



### 3.2 16-bit 实模式

CPU的生产厂家必须大费周折的让他们的cpu和以前的cpu相兼容，以便那些老旧的程序和操作系统可以在现在的最新cpu上运行。

由Intel实施的解决方案和那些兼容的cpu其实就是去模拟atsyige体系里的那些老cpu：Intel 8086cpu，他支持16-bit的指令，但是并没有内存保护的概念。内存保护对于现在操作系统的稳定性非常重要。，它可以限制用户程序的随意接入、表达以及对内核的存储，这些操作无论时有意还是无意，都可能会规避系统的安全机制或者甚至上整个系统宕机。

所以，为了向后兼容，cpu在启动引导的时候使用16-bit的实模式时很重要的，它可以让现代操作系统转到更高级的保护模式（32-bit或者64-bit），也可以让老旧的操作系统完美加载，而不让他们直到自己正运行在一个更高级的cpu上。一会，我们将要仔细研究这个从16-bit实模式到32-bit保护模式转换过程的细节。

总而言之，当我们说这个cpu是16-bit的时候，这意味着他的指令一次只能处理最大16位的运算。举个例子，一个16-bit的cpu有一个指令可以在一个cpu周期内运算两个16-bit数字的加法，但是如果我们需要计算两个32-bit的数字加法，就需要用16-bit的加法指令花费更多的cpu周期进行运算。

首先，我们先探索一下16-bit实模式环境，因为所有操作系统都是从这里开始的，然后我们再看看如何转换成32-bit保护模式，以及这样的主要好处。








