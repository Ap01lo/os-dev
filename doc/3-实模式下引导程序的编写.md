## 第三章 实模式下引导程序的编写

尽管有了实例代码，我相信让你用二进制编辑器写二进制代码的时候你依然很懵逼。你必须记住，或者要经常的查阅哪些机器码会让cpu做哪些事情。但幸运的是，你并不孤单，我们发明了汇编器，它可以将我们易用的代码翻译成针对某种特定cpu的机器指令。

在这一章节里，我们将会深入研究一些越来越复杂的引导扇区的代码，以便熟悉汇编过程和将要运行我们程序的简陋的操作系统预环境。

### 3.1 重温引导扇区

现在，我们要重新创建用二进制编辑器编写的引导程序，而不使用汇编代码，这样我们就可以清楚的看到底层语言的值了。

我们可以使用如下命令将其汇编成真实的机器码（一串计算机可以翻译成指令的字节数字）：

```
$ nasm boot_sect.asm -f bin -o boot_sect.bin
```

其中， `boot_sect.asm` 是我们在图3.1写的源码保存下来的文件， `boot_sect.bin` 是我们可以加载到磁盘引导扇区的汇编好的机器码。

注意，我们使用了 `-f bin` 参数来指示nasm生成原始的机器码，而不是我们在更复杂操作系统环境中可能会使用的带有其他元链接信息的代码包。我们并不需要这些累赘代码。除了更底层的bios代码之外，我们现在是机器上能跑的唯一程序的了。我们现在就是一个操作系统，尽管我们现在除了提供一个无尽循环之外、什么也干不了，但我们将会从这里开始一点一点搭建。

```nasm
图 3.1 一个用汇编语言写的简单引导程序

;
;    一个无限循环的引导程序
;

; 定义一个loop地址，以便我们可以跳转
loop:

    ; 使用简单的cpu指令，可以跳转到新的地址继续执行。
    ; 在我们的例子中，我们跳转至我们当前所执行的指令
    jmp loop                     ; 

; 当编译的时候，我们的程序必须是512字节
; 而且最后两字节必须是魔法数字
; 因此这里，我们告诉汇编器，用零填充剩余的字节直到510字节
times 510-($-$$) db 0

; 剩下的两个字节填充魔法数字
; 此时，BIOS 可以识别出来，我们是引导扇区了
dw 0xaa55
```

不需要将程序写入软盘或者硬盘，我们通过运行bochs就可以测试程序：

```shell
$ bochs
```

或者，根据喜好以及模拟器的功能，我们可以使用qemu：

```shell
qemu boot_set.bin
```

当然，你也可以将映像文件加载到虚拟机上或者写入一些可以承载引导程序的媒介上去。但是要注意，当你将印象文件写入一些媒介中时，并不代表你将程序写到了该媒介的文件系统中去，你需要使用一些合适的工具将其直接写入引导区块。

如果想更简单直接的看到汇编器到底生成了什么，我们可以运行下面的程序将二进制变为可观的十六进制：

```shell
$ od -t x1 -A n boot_sect.bin
```

这个命令的输出结果你一定很熟悉。

恭喜了，你已经成功使用汇编语言写了一个引导程序了。对于所有的操作系统，他们都需要用这种方式来启动，然后一步一步走到更高更抽象的层级（使用高级语言，比如C, C++）

### 3.2 16-bit 实模式

CPU的生产厂家必须大费周折的让他们的cpu和以前的cpu相兼容，以便那些老旧的程序和操作系统可以在现在的最新cpu上运行。

由Intel实施的解决方案和那些兼容的cpu其实就是去模拟atsyige体系里的那些老cpu：Intel 8086cpu，他支持16-bit的指令，但是并没有内存保护的概念。内存保护对于现在操作系统的稳定性非常重要。，它可以限制用户程序的随意接入、表达以及对内核的存储，这些操作无论时有意还是无意，都可能会规避系统的安全机制或者甚至上整个系统宕机。

所以，为了向后兼容，cpu在启动引导的时候使用16-bit的实模式时很重要的，它可以让现代操作系统转到更高级的保护模式（32-bit或者64-bit），也可以让老旧的操作系统完美加载，而不让他们直到自己正运行在一个更高级的cpu上。一会，我们将要仔细研究这个从16-bit实模式到32-bit保护模式转换过程的细节。

总而言之，当我们说这个cpu是16-bit的时候，这意味着他的指令一次只能处理最大16位的运算。举个例子，一个16-bit的cpu有一个指令可以在一个cpu周期内运算两个16-bit数字的加法，但是如果我们需要计算两个32-bit的数字加法，就需要用16-bit的加法指令花费更多的cpu周期进行运算。

首先，我们先探索一下16-bit实模式环境，因为所有操作系统都是从这里开始的，然后我们再看看如何转换成32-bit保护模式，以及这样的主要好处。

### 3.3 Hello

现在，我们将要写一个简单的引导程序，可以在屏幕上显示一些信息。要做到这个，我们首先要学习一下cpu工作的基础知识以及我们应该如何借助BIOS来控制屏幕设备。

首先，我们得想想我们应该做些什么。我们想要在屏幕上输出字符，但是我们还不知道如何跟显示设备交互，因为可能会有很多种类的显示器，并且他们各自还会有不同的接口。因此我们需要BIOS，因为BIOS已经做了一些对硬件的自动检测，而且事实上，我们可以看到BIOS已经成功在屏幕上输出了一些自检相关的信息，所以它可以帮助我们。

所以接下来，我们要让BIOS在屏幕上为我们输出字符，但是如何让BIOS做的这一点呢？这里没有JAVA的库函数可以用，现在的阶段是不可能的。但是我们可以确定，在存储设备的面个位置，一定存在着一些BOIS指令的机器码，这些机器码可以帮助我们在屏幕上输出。但是实际上，想要找到这些BOIS代码并且执行是非常麻烦的，而且很有可能会报错，因为在不同的机器上，BIOS的内部代码也会有所不同。

在这里，我们会使用一个计算机的基本功能：中断。

#### 3.3.1 中断

中断是一个计算机内部的机制，它允许cpu可以暂时的停下正在做的任务，而去做一些其他的更高优先级的任务，之后再返回原任务。一个中断可以被软件指令引起，也可以被一些需要更高优先级操作的硬件设备发起（比如从网络设备中读取输入数据）。

每一种中断都由一个单独的数字符号所表示，这些数字同时也是中断向量表的索引，中断向量表由BIOS在物理内存最开始的地方建立（0x0），包含了指向各种中断服务程序（ISR）的指针，一个ISR实际上是一系列的机器指令集合，就像我们的引导程序一样，用来处理一个特定的中断（比如从硬盘或者网卡中读取数据）。

所以，简而言之，BIOS会将自己的一些ISR添加到中断向量表中去，这些ISR会负责计算机的某个方面，比如：中断号为 `0x10`的中断可以调用屏幕显示相关的ISR，中断号为`0x13`的中断可以调用与磁盘相关的ISR。

然而，对于计算机来说，对每个BIOS例程都分配一个中断会比较浪费资源，所以BIOS将这些ISR复用了，通过我们能想通的 `switch`方式，根据常驻在cpu中的一个通用寄存器`ax`的值来确定执行哪个中断。

#### 3.3.2 CPU 寄存器

正如我们在高级语言中使用的变量一样，我们在一个特定的例程中可以短暂的存储数据是非常有用的。所有的 x86 CPU都有四个通用寄存器：`ax,bx,cx,dx` 就是为了实现上述目的。对于每个寄存器，他们都可以存储一个字（两个字节，16 位)的数据，还可以用跟访问主存比起来能够忽略的延迟进行读写。在汇编语言中，一个最常用的操作就是在两个寄存器之间移动数据（或者更精确的叫做复制）：

```nasm
mov ax, 1234     ; 将十进制数 1234 存进ax
mov cx, 0x234    ; 将十六进制数 0x234 存进cx
mov dx, 't'      ; 将 ASCII 字符 't' 村润dx 
mov bx, ax       ; 将ax中的值赋值到bx中，因此现在 bx==1234
```

需要注意，`mov` 操作的目标地址在第一个参数而不是第二个参数，但是这个规律会随着不同的汇编器而不同。

有时，单独操作单字节会更加方便，所以让我们再试试单独设置这些寄存器的高位和低位：

```nasm
mov ax, 0            ; ax -> 0x0000
mov ah, 0x56         ; ax -> 0x5600
mov al, 0x23         ; ax -> ax5623
mov ah, 0x16         ; ax -> ax1623
```

#### 3.3.3 整合在一起

因此，回想一下，我们想要BIOS给我们在屏幕上输出字符，就可以将 `ax` 寄存器设置为某个BIOS已经规定好的值，然后调用对应的BIOS用例进而触发中断。在这里我们想要的特定用例是滚动输入宫功能，就是在显示器上输出一个字符后将光标前进一个单位，然后等待下一次输出。有一个完整的BIOS例程表，上面描述了应该使用什么中断，以及如何设置寄存器的优先级来出发中断。在这里，我们需要 `0x10`号中断，同时要将 `ah` 设置为 `0x0e` 来代表滚动输入模式，将 `al` 设置为我们想要显示的字符的ASCII码。

```nasm
图 3.2
;
; 一个使用BIOS例程将信息输出到屏幕上的引导程序 
;

; 对于0x10 号中断, ah = 0eh时进入滚动输入模式
mov ah, 0x0e

mov al, 'H'
int 0x10

mov al, 'e'
int 0x10

mov al, 'l'
int 0x10

mov al, 'l'
int 0x10

mov al, 'o'
int 0x10

; 跳转到当前地址，并永远循环
jmp $ 

; 用0 填充剩下的位数，并补齐魔法数字
times 510-($-$$) db 0

dw 0xaa55
```

图3.2 显示了整个的引导程序，要注意，在这个例子中，我们只需要将`ah` 设置一次，然后将 `al` 多次设置为不同的字符就好。

```context
图3.3
b4 0e b0 48 cd 10 b0 65 cd 10 b0 6c cd 10 b0 6c
cd 10 b0 6f cd 10 e9 fd ff 00 00 00 00 00 00 00
...
00 00 00 00 00 00 00 00 00 00 00 00 00 00 55 aa 
```

为了完整性，图3.3显示了以上程序的原始机器码，这些会告诉cpu应该做什么。如果你对我们已经达成的成绩很惊讶，而且开始理解我们在写这个简单实用的程序中所涉及的东西，那么请你记住，这些指令的执行与cpu的运行周期是非常接近的，所以他们很简单，而且也很快。你将会慢慢掌握你的计算机了，正如我们现在在做的这样。

### 3.4 Hello, World!

现在，我们将尝试把我们的hello程序写的稍微高级一点，引入了一些cpu的基础知识以及一些对BIOS将引导程序放入内存中的理解。

#### 3.4.1 内存，地址，和标签

我们曾经说过cpu如何从内存中取指令并且执行，也说过BIOS是如何将512byte的引导程序加载到内存中，然后完成初始化，告诉cpu跳转到我们程序的开头，并且从这里一条一条的执行指令。

所以我们的引导程序会被加载到内存中，但是会被放在哪里呢？我们可以设想，主存是一连串的字节组成的二进制数串，并且可以被一个地址所访问，所以，如果我们想得到内存中第54个字节的数据，那就把54当作地址，当然，我们用十六进制的 0x36 来表达会更方便些。

因此，我们的引导程序最开始的第一个字节，也就是最开始的机器码，存在于内存的某个位置，而且，是BIOS放在那里的。如果我们不了解的话，可能会猜想：BIOS会将我们的程序放在内存的最开头：`0x00`。然而并没有这么简单，因为我们知道，BIOS在加载我们的引导代码之前，还做了一些初始化工作，这些工作会继续为之后的时钟，硬盘等等设备提供中断调用服务。所以这些BIOS例程（ISR）要被存放在内存的某个地方而且要在被使用的时候保护起来（不可更改）。我们也注意到之前的中断向量被加载到了内存的最开始地方，如果BIOS将我们的代码加载到那里去，我们的代码将会在下一次中断执行时覆盖掉这些例程，电脑就可能会宕机或者重启：因为此时，中断号与ISR之间建立的映射已经被割裂。

最后大家证实，BIOS喜欢将引导程序加载到地址`0x7c00`处，而且可以确定，这里没有被重要的例程占据。图3.4 给了一个在低地址布局下引导程序被加载后的分布。所以当我们指示cpu在内存任意位置写数据的时候，很可能造成不好的结果，因为一些内存空间被一些重要的例程所占据，比如时钟中断，硬盘设备等等。

```context
图3.4

0x100000----------------------
            BIOS(256KB)
0xc0000-----------------------
        Video Memory(128KB)
0xA0000-----------------------
        Extented BIOS Data
            Area(639KB)
0x9fc00-----------------------
            Free(638KB)
0x7e00------------------------
        Loaded Boot Sector 
            (512 bytes)
0x7c00------------------------
               Free
0x500-------------------------
        BIOS Data Area(256KB)
0x400-------------------------
        Interrupt Vector Table
                (1KB)
0x000--------------------------
```

#### 3.4.2

接下来我们要玩一个游戏，名字叫做“找到那个字节”，这个游戏将会说明清楚内存的指向，汇编代码中标签的使用，以及知道我们的代码被加载到哪里的重要性。我们将要写一个汇编程序，为一个字母数据保留一个字节，然后我们将试着将它输出到屏幕上。为了完成这个任务，我们就得知道a他的绝对内存地址，以便我们可以将其加载到 `al`寄存器上然后让BIOS打印出来，就像我们上个例子一样。

```nasm
; 一个简单的引导程序，来说明地址问题

mov ah, 0x0e ;进入0x10号中断时选择滚动输入模式

; 第一次尝试
mov al, the_secret
int 0x10
; 第二次尝试
mov al, [the_secret]
int 0x10
; 第三次尝试
mov bx, the_secret
add bx, 0x7c00
mov al, [bx]
int 0x10
; 第四次尝试
mov al, [0x7c1e]
int 0x10

jump $

the_secret:
    db "X"

times 510-($-$$) db 0

dw 0xaa55
```

首先，我们在程序中声明数据的时候，使用一个前缀标签，比如上面的 `the_secret`。我们可以在程序的任何地方使用标签，因为它唯一的作用就是给我们提供一个当前数据或者指令相对于程序开头的偏移地址。

如果我们观察汇编好的机器码，可以发现我们的 "X" （ASCII码为0x58）处在距离代码开头偏移地址为30（0x1e）的地方，正好在我们用零填充的数据之前。

如果我们运行程序，会发现只有后两个代码才能成功打印输出一个”X“。

第一个测试程序的问题在于，它直接将偏移地址当作数据加载进了 `al`，我们要的是存在该地址中的数据，而不是该偏移地址。正如第二个测试程序所做的，他用了方括号，这是用来告诉cpu，这代表地址里存放的数据。

但为什么第二个错了呢？问题在于，这种用法会让cpu将该地址认为成是相对内存一开始的偏移地址，而不是相对于我们引导程序的偏移地址，这样可能回获取到一些中断向量数据。在第三个测试用例中，我们使用了加法指令，加入了 `the_secret`偏移地址，并且我们默认BIOS已经将我们的程序加载到地址`0x7c00`的位置。可以将加法指令看作更高级的`bx = bx+0x7c00`我们现在已经计算出了我们定义的 "X" 的正确地址，就可以将该地址所存下的内容加载到`al`中，准备让BIOS执行输出功能。

在第四个测试用例中，我们变得聪明了些，提前算出了字符”X“在BIOS将我们的引导程序加载到内存中后的偏移地址。我们根据编译好的二进制文件得到字符"X"的地址 `0x7c1e`，可以看出相对于代码开始，他的相对便宜地址为`0x1e`。这第四个用例也提示我们，标签真的很有用，不然如果我们想得到某处数据的地址，只能去数编译好的二进制文件了。

所以，现在我们已经知道BIOS是如何将我们的引导程序加载到地址`0x7c00`处了，也知道了地址和汇编代码的标签到底有何联系。

如果每次都在内存中去数标签的相对偏移地址的话非常的不方便，所以，很多汇编器都会在汇编的过程中自动修正标签偏移，前提是你要加上以下的指令来告诉编译器你想让BIOS将你的代码加载到什么位置：

```nasm
org 0x7c00
```

##### 问题一

如果在你已经写好的引导程序中加上上面的指令，你觉得现在会输出什么？解释一下为什么。

> ```nasm
> org 0x7c00
> 
> the_secret:
>     db "X"
> 
> mov ah, 0x0e
> 
> mov al, [the_secret]
> int 0x10
> 
> times 510-($-$$) db 0
> dw 0xaa55
> ```

> 如果使用了 `org 0x7c55`指令，那么就可以告诉汇编器，所有的偏移地址都是以 `0x7c00`为基址的，所以使用 `mov al, [the_secret]`就可以输出字符 "X"

#### 3.4.3 定义字符串

假设你想要在屏幕的某个位置输出一个提前定义好的消息（比如 ”Booting OS“），你应该如何在汇编程序中定义这样的字符串呢？我们得时刻提醒自己，电脑是不懂什么是字符串的，这对于他来说就是一串连着的字符单位，存储在内存的某个地方。

在汇编器中，你可以这样定义字符串:

```nasm
my_string:
    db 'Booting OS'
```

我们已经见到过 `db` ，翻译过来就是 `declare byte` （定义字节数据），这会告诉汇编器将接下来的字节数据直接写到二进制输出文件中去（不把它当作指令）。由于我们用引号将数据扩了起来，所以汇编器会将数据转换成ASCII码。要注意的是，我们通常会使用一个标签来标记我们所定义数据的起始位置，除此之外，在代码中并没有更好的方法了。

在这个例子中，我们忽视了一件事，那就是，知道字符串有多长跟知道数据存放在哪里一样重要。因为是我们自己在写有关字符串控制的代码，所以对字符串长度有一个连贯的分配策略是非常重要的。这样会有很多种方法和可能，但是我们一般会约定，字符串数据以空字符结尾，也就是最后一位必须为0，如下所示：

```nasm
my_string:
   db 'Booting OS',0
```

当之后在字符串数据中迭代时，a可能要按顺序输出所有字符，此时我们可以轻松的确定什么时候到达了末尾。

#### 3.4.4 使用栈

当谈论到底层计算的话题时，我们总是听见大家谈论栈，似乎是一个特别的东西。栈，其实就是一个我们对发现的不便问题采取的一种简单的解决方案：对于我们例程中局部变量的临时存储，CPU只有有限个寄存器供我们使用，但是我们实际需要的会更多。现在，我们显然可以使用主存，但是这样的话对于特定地址的读写就会比较麻烦，因为我们并不关心数据到底被存在哪里，只要能方便的得到就够了。因此，我们将会看到，栈同样是在响应函数调用时传递参数的一种有效方法。

所以，CPU提供了两种方法 `push pop` 允许我们从栈顶分别存储和取回一个值，而且不用关心他被放在哪里。需要注意的是，我们无法 `push` 和`pop` 单字节的数据，因为栈是以16-bit工作的。

栈的操作由两个cpu的寄存器 `bp,sp` 执行，他们分别包含了栈的基址，栈顶的地址。因为栈会随着我们的 `push` 操作而扩展变大，所以我们对栈基址的位置选取要远离重要的内存区域（比如 BIOS 和 我们的引导代码），这样的话如果栈变大，就不会有覆写的危险。关于栈的一个比较烦人的问题是，他会以栈底为基准向下扩展，因此当我们进行`push`操作的时候，数据会存在下方，而不是上方，也就是说 `bp,sp` 的值会随着数据量增大而递减。

图3.6中的引导程序里展示了栈的用法。

```nasm
图3.6

; 引导程序，展示栈的用法


mov ah, 0x0e

mov bp, 0x8000
mov sp, bp

push "A"
push "B"
push "C"

pop bx
mov al, bl
int 0x10

pop bx
mov al, bl
int 0x10

mov al, [0x7ffe]
int 0x10

times 510-($-$$) db 0
dw 0xaa55
```

#### 问题2

图3.6中的代码会打印出什么？字符“C”会被存储在什么绝对地址？你会发现，修改你的代码是一个很有用的证明你的猜想的方式，但是记得务必解释一下为什么他在那里。

> push操作时，高位存在低地址，对于 ‘A’来说 完整的两个字节应该是：`0x00,0x41` ，因此0x41存在栈一个单元内的高地址，`pop`操作时，高地址会存放在目标寄存器的高位，低地址会存放在高位。

#### 3.4.5 控制结构

如果在编程的时候我们不知如何写简单的控制结构，那将会很难受的，比如`if..else..then..elseif,for,while`。这些结构提供了基本的分支流程，是一段可行代码的基础。

在编译后，这些高级语言的控制结构会精简成为简单的 `jump` 跳转语句，事实上，我们已经见过了最简单的循环语句：

```nasm
some_lable:
    jmp some_lable
```

或者，我们可以用以下语句实现相同的结果

```nasm
jmp $
```

这个语句为我们提供了无条件跳转操作（直接跳转），但是我们通常也会需要一些根据条件跳转的情况（比如循环十次之后停下）。

条件跳转在徽标语言中的实现通常需要先执行一个比较指令，然后再执行一个特定的跳转指令。

```nasm
cmp ax, 4
je then_block

mov bx, 45
jmp the_end

then_block:
    mov bx, 23
then_end:
```

在C语言或者java语言中，通常会写成这样：

```c
if(ax == 4){
    bx = 23;
} else {
    bx = 45;
}
```

我们可以从上面的汇编代码中看见，在 `cmp`和`je` 指令运行时，一定在运行的背后发生着什么。这是因为cpu特殊的标志寄存器被用来捕捉 `cmp`指令的输出结果，因此后面的条件跳转指令可以根据这个决定是否、跳转到相应的地址处。

下面的跳转指令都是可用的，他们都是基于 `cmp x, y` 指令运行的：

```nasm
t -> target
je t ; jump if equal   x==y
jne t ; jump if not equal x!=y
jl t ; jump if less than x<y
jle t ; jump if less than or equal x<=y
jg t; jump if greater than x>y
jge ; jump if greater than or equal x>=y
```

#### 问题3

在写高级代码时，提前规划好结构控制语句通常都是很重要的，接下来想办法将他们用汇编语言换掉。你需要将这个伪汇编指令转换成完整的汇编代码，需要使用 `cmp` 和正确的跳转指令。使用不同的bx值来判断。

```nasm
mov bx, 30

if(bx <= 4){
    mov al, 'A'
} else if(bx < 40){
    mov al, 'B'
} else {
    mov al, 'C'
}
mov ah, 0x0e
int 0x10

jmp $

times 510-($-$$) db 0
dw 0xaa55
```

**解：**

```nasm
mov bx, 30

cmp bx, 4
jle A

cmp bx, 40
jl B

mov al, 'C'
jmp the_end

A:
    mov al, 'A'
    jmp the_end

B:
    mov al, 'B'
    jmp the_end

the_end:
    mov ah, 0x0e
    int 0x10

    jmp $

times 510-($-$$) db 0
dw 0xaa55
```

#### 3.4.6 调用函数

在高级语言中，我们通常会把打的问题分解成许多小函数，这些函数具有通用的功能，我们可以在程序中反复使用，只需要通过改变需要的参数来得到不同的结果。在CPU的处理层面上，调用函数不过就是跳转到另一段有效程序的地址，然后再跳转回来接着第一次跳转继续执行。

我们可以使用这种方式模拟函数调用：

```nasm
...
...
mov al, 'H'
jmp my_print_function

return_to_here:
...
...
my_print_function:
    mov ah, 0x0e
    int 0x10
    jmp return_to_here
```

首先我们要注意，如何将 `al` 当作参数，并且设置好后准备让函数使用。这就是高级语言所创建的参数传递的方式，调用的和被调用的必须在被传递参数的数量和位置上保持一致。

但是很让人失望，这种方法最大的瑕疵就是我们需要很精确的说明清楚函数执行完毕后应该返回到什么地址，这就意味着，我们不过在程序的任意一个地方调用这一段函数，因为他总是会返回到同一个地址，在这个例子中，会返回到地址`return_to_here`。

如果从参数传递的角度借鉴一些想法的话，函数调用者应该某个公共位置存储下来精确的返回地址，然后被调用的函数就能根据这个地址返回到先前的执行位置。cpu使用寄存器ip来追踪当前正在执行的指令地址，但是我们无法直接获取它。然而，cpu还提供了一对指令：`call 和 ret` ，这两个指令正好可以完成我们想要的功能。`call` 的执行就像 `jmp`,但是除此之外，他还在跳转之前将此处的返回地址压栈，`ret`就会将返回地址出栈，然后跳转回去，就像下面的一样：

```nasm
...
...
mov al, 'H'
call my_print_function
...
...
my_print_function:
    mov ah, 0x0e
    int 0x10
    ret
...
```

我们的函数已经基本自洽了，但是仍然有个憨憨的问题，如果我们现在注意一下，以后一定会感激自己的。当我们调用函数时，比如这个打印输出函数，在汇编程序里，这个函数为了执行操作，可能会替换掉一些寄存器的值，事实上，寄存器作为稀缺资源，它完全有可能这样，所以当我们的程序从函数调用中返回时，很难说我们存在 `dx`中的值还是原来的值。

因此，对于一个将要被调用执行的函数，将它可能要替换数据的寄存器的值压入栈中，然后在返回之前在出栈，是一个可行的，合理的选择。由于一个函数可能会使用多个通用寄存器，cpu可以执行两个方便的指令：`pusha 和 popa` ，可以将所有的寄存器值分别压栈和出栈，比如：

```nasm
...
...
some_function:
    pusha
    mov bx, 10
    add bx, 20
    mov ah, 0x0e
    int 0x10
    popa
    ret
```

#### 3.4.7 导入文件

在全面的使用了看起来最小的汇编函数之后，你可能还想要把你的代码在多个程序中使用，nasm支持这个操作，你可以向下面一样导入外部文件：

```nasm
%include "my_print_function.asm"

...
mov al, "H"
call my_print_function
```

#### 3.4.8 整合

我们现在已经掌握了足够的关于cpu和汇编语言的知识了，完全可以写一个更加复杂的 "Hello World!"引导程序。

#### 问题4

在这一部分，将所有想法汇聚到一起，完成一个自洽的在屏幕上输出空字符结尾字符的函数，使其可以像下面一样使用：

```nasm
[org 0x7c00]

mov bx, HELLO_MSG
call print_string

mov bx, GOODBYE_MSG
call print_string

jmp $

%include "print_string.asm"

HELLO_MSG:
    db 'Hello,World!',0
GOODBYE_MSG:
    db 'Goodbye!',0

times 510-($-$$) db 0
dw 0xaa55
```

**解：**

```nasm
print_string:
    pusha
    mov ah, 0x0e
loop:
    call print_char
    add bx, 1
    mov cl, [bx]
    cmp cl, 0
    jg loop
    jmp the_end

print_char:
    mov al, [bx]
    int 0x10
    ret

the_end:
    popa
    ret
```
