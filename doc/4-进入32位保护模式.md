## 第四章 进入32位保护模式

对于使用已经掌握的知识在16位的实模式下操作，我们已经变得更加熟悉了，但是为了更好的利用CPU的资源，以及更好的理解CPU加架构的发展对现代操作系统有什么好处，也就是所谓硬件层面的的内存保护，我们必须要着重于32位的保护模式了。

处在32位保护模式时，主要的区别在于：

+ 寄存器被扩展到了32位，如果要完整访问一个寄存器的所有容量，需要在寄存器名称前加前缀`e`,比如 :`mov ebx, 0x2743e8fe`
+ 为了操作方便，增加了两个额外的寄存器`fs 和 gs`
+ 32位的内存地址偏移同样时可行的，所以通过偏移，可以访问巨大的 **4GB** 的内存空间（0xffffffff）
+ CPU支持一个更加成熟的，当然也相对复杂一点的内存分段方式，有两个好处：
	+ 当在一个段内编程时，可以不受到正在运行的高优先级的程序的破坏，所以你保护你的内核代码不受用户应用的破坏。
	+ CPU可以为用户程序执行虚拟内存，这样一来，像页这样的程序内存可以在硬盘和内存中透明的传输。这可以确保主存被有效利用，那些几乎不怎么使用的程序解不会占据更有用的内存资源了。
	+ 中断操作同样也变的成熟了。

从16-bit实模式向32-bit保护模式转变的过程中最难的一部分是，我们需要定义一个非常复杂的叫做 全局描述表（Global discriptor table，GDT）的数据结构，它里面定义了内存分段，以及一些保护模式的属性。我们在定义好GDT后，可以使用特定的指令把他加载到cpu中去，然后再对特殊的控制寄存器进行设置，完成实际的转换。

如果我们不需要使用汇编语言来定义GDT的话，这个工作会非常简单，但是很无奈，这种低级别转换是不可避免的，我们需要它来加载从高级语言编译好的内核指令，比如c语言，这些高级语言一般都会被编译成为32位的指令，而不是低效的16位指令。

有个还重要的事情我忘记说了：当我们转换到32位保护模式时，就已经不能再使用BIOS了。如果你认为使用BIOS调用很低级的话。这就像，退后一步，但是前进两步。

###  4.1 适应没有 BIOS 的生活

这是真的：在我们对完全利用CPU的探索中，我们必须放弃所有那些BIOS为我们提供的有用的程序。因为我们在深入32位保护模式的时候，会发现，那些只能在16位实模式下运行的BIOS程序，在32位保护模式已经失效了；事实上，尝试使用他们，是在破坏计算机。

所以，这就意味着，32位的操作系统需要对机器上的所有硬件提供自己驱动程序（比如键盘，屏幕，硬盘，鼠标等等）。实际上，对于32位操作系统来说，短暂的切换回16位实模式然后使用BIOS是可行的，但是这种方式带来的问题远大于他的作用，起码从性能表现来看是这样的。

我们在转换模式之后遇到的第一个问题就是如何在屏幕上输出一段信息，我们先来看看再这个过程中会发生什么。之前，我们曾让BIOS在屏幕上输出字符，但是，如何做到让电脑屏幕上对应位置上的对应像素亮起呢？现在，我们需要知道，显示设备可以被配置成多种模式中的一种：文本模式以及图像模；并且，显示在屏幕上的东西，其实是特定范围的一段内存值的视觉呈现。所以，为了控制屏幕，我们需要控制当前模式下的特定内存范围。显示设备就是一个内存映射的例子，因为他就是这么工作的。

当大多数电脑启动时，当然除了那些带有高级显示器的，他们都会启动一个简单的VGA彩色文本模式，大小为 $80 \times 25$ 字符。在文本模式中，程序员不需要提供每个字符精确的像素信息，因为在VGA显示设备的主控内存中，已经定义好了每个字符。屏幕上的每个字符都用2个字节来表示，第一个字节是字符的ASCII码，第二个字节是字符的属性，比如前景色，背景色，是否需要闪烁等。

所以，如果我们想要在屏幕上输出字符，就需要在当前的VGA模式下，在对应的内存处设置ASCII码以及属性，这个内存地址通常是`0xb8000`。如果我们简单的改改我们在16位实模式下的 `print_string`代码，就可以得到一个不需要使用BIOS中断程序的32位的保护模式代码，可以直接向显示器的内存处写入数据，如图4.1所示。

```nasm
; 图 4.1

[bits 32]

VIDEO_MEMORY equ 0xb8000
WHTIE_ON_BLACK equ 0x0f

print_string_pm:
	pusha
	mov edx, VIDEO_MEMORY
	
print_string_pm_loop:
	mov al, [ebx]
	mov ah, WHITE_ON_BLACK
	
	cmp al, 0
	je print_string_pm_done
	
	mov [edx], ax
	
	add ebx, 1
	add edx, 2
	
	jmp print_string_pm_loop
	
print_string_pm_done:
	popa
	ret
```

这段代码通常情况下，会在屏幕的左上角输出字符，所以会覆写先前的数据，而不是向下接着写。我们需要花时间在这个汇编代码上增加更复杂的功能，但是也别太着急，在我们掌握了保护模式之后，我们就可以使用高级语言来编写代码，可以更轻松的实现这些功能。

### 4.2 理解全局描述符表（GDT）

理解GDT的主要内容是非常重要的，在我们深挖细节之前，这是保护模式的基础内容。回想一下，在传统的16-bit的实模式中，我们通过分段的寻址方式来让程序员获得更大的寻址空间。以此为例，想象一下，程序员希望把 `ax`中的值存储在 `0x4fe56`内存处。如果没有分段基址，程序员能做的最好情况是：

```nasm
mov [0xffff], ax
```

这完全没达到我们的要求。如果使用分段方式进行寻址，那么就可以这么做：

```nasm
mov bx,0x4000
mov es, bx
mov [es:0xfe56], ax
```

虽然采用分段和偏移地址来寻址的想法没有变，但是在保护模式中的实现方法完全改变了，变得更加灵活。一旦CPU转换成了保护模式，那么将逻辑地址翻译成实际物理地址的过程是不同的：保护模式下，没有把段寄存器的值乘16然后与偏移地址相加，而是将段寄存器中的值变成了GDT中的一个段描述符（segment descriptor，SD）。

一个段描述符是一个8字节的数据结构，它定义了保护模式下一个段的以下属性：

+ 基址（32位），定义了段的其实位置在物理内存的什么位置
+ 段的范围（20位），定义了段的大小
+ 不同的标志位，影响CPU对段的处理，比如运行在段内的代码的优先级，或者段到底是可读还是可写

图4.2展示了实际上段描述符的结构。你是否注意到，这个数据结构是如何划分段基址与段长的，举个例子，段长的低16位存在于数据结构的前两个字节，但是高四位在第七个字节里，当然这只会徒增烦恼。或许，这里有什么渊源，或者受到CPU硬件设计所影响吧。

我们不用担心那些段描述符里的详细配置，在Intel的开发者手册里面有详细的介绍，但是我们需要学一些必要的知识以便我们可以在32位的保护模式下运行程序。

在段寄存器中最简单可行的配置，被Inter称之为 `基本flat模型`，两个相互重叠的段 `code` 和`data`被定义在整个可寻址的4GB内存空间里。相互重叠是指，没有保护措施将两个段分开，也没有任何将分页当作虚拟内存的方法。在早期，把这些东西弄的很简单是有好处的，特别是当我们进入保护模式以后，可以使用高级语更简单的修改段描述符。

除了两个段 `code 和data`，CPU还要求GDT的第一个入口必须为一个空描述符（由8个0组成的字节结构），这时一个简单的错误捕捉机制，当我们切换到保护模式后，在访问某个内存地址时将某个段寄存器设置为 `0x00`，没有修改成正确的值时，CPU就会抛出一个中断，有点类似于高级语言中的异常，比如Java。

我们的 `code`段将会有如下的配置属性：

+ Base: 0x0
+ Limit: 0xfffff
+ Present: 1，因为段在内存中呈现，作为虚拟内存
+ Privilege: 0，0时最高优先级权限
+ Descriptor type: 1 是 code 和data， 0 是traps
+ Type：
	+ Code：1是code，因为这是code段
	+ Conforming：0，如果不进行确认，更低等级的代码段中的代码不会唤醒此段的代码，这也是内存保护的关键
	+ Readable：1，1-可读，0-只能执行，可读性允许我们读代码。
	+ Accessed：0 ，这通常被用来调试以及虚拟内存技术，因为CPU访问段时会更改bit数据。
	+ 其他标志：
		+ Granularity：1，如果设置，这将会把我们的内存大小乘4K，所以我们的 0xfffff将会变成0xfffff000（左移三个16进制位），能够扩大4GB的内存
		+ 32-bit default：1，因为我们的段会包含32位的代码，如果设为0，则默认16bit代码。这个属性实际设置了操作默认数据单元的大小。
		+ 64-bit code segment：0，在32位处理器中无效。
		+ AVL：0，可以自己设置来用，但是我们用不着。

因为我们使用了简单的flat模型，code段和data段是重叠的，所以data段的设置是一样的，除了type标志位：

+ Code：0 代表数据
+ Expand down：0，这个允许段向下扩展--
+ Writeable：1，这个允许data段被写入数据，否则就只读
+ Accessed：0，通常用来调试和虚拟内存。

现在我们已经看见了两个段的实际配置，探索了大多数可能的段描述符设置，应该对保护模式提供了更灵活的内存分配方式有更深刻的理解了。

### 4.3 用汇编语言定义GDT

既然我们理解了在基础的flat模式的GDT中段寄存器会包含什么内容，就让我们继续着眼于用汇编语言怎么描述GDT吧，这是一个比以往任何任务都需要耐心的任务。当你做这件事的时候正处在极度的无聊之时，别忘了他的重要性：它可以加载我们使用高级语言写成的操作系统，在这之后，我们的一小步，就变成了巨大的飞跃。

我们已经了解了在汇编语言中如何定义数据，需要使用`db,dw,dd`这些汇编指令，我们也要使用他们在GDT的段描述符的入口处定义对应的字节数据。

事实上，由于CPU需要知道我们的GDT有多大，所以我们不用直接告诉他我们的GDT的入口地址，而是给他一个相对更简单的数据结构，叫做GDT描述符。GDT描述符包含来6字节的数据：

+ GDT大小（16bits）
+ GDT地址（32bits）

要注意，当在这个低级语言中使用如此复杂的数据结构时，我们一定要加入足够的注释。下面的代码定义了GDT以及GDT描述符；在代码中，要注意我们如何使用 `db,dw,dd`来填充数据结构中的每个部分，以及我们如何使用前缀`b`更方便的设置标志位：

```nasm
; GDT
gdt_start:

gdt_null:	; gdt 开始的空段描述符，8 bytes
dd 0x0		; 应该也能用 times 8 db 0x00
dd 0x0

gdt_code:	; gdt code 段描述符
; base = 0x0, limit = 0xfffff
; 1st flags: (present)1 (privilege)00 (type)1 -> 1001b
; type flags: (code)1 (conform)0 (accessed)0 --> 1010b
; 2nd flags: (granularity)1 (32-bit default)1 (64-bit seg)0 (AVL)0 -->1100b

dw 0xffff	; limit (bits 0-15)
dw 0x0		; Base (bits 0-15)
db 0x0		; Base (bits 16-23)
db 10011010b; 1st flags, type flags
db 11001111b; 2nd flags, Limit (bits 16-19)
db 0x0 		; Base(bits 24-31)

gdt_data:	; gdt data段描述符
; 与code段一致，除了type flags
；type flags:(code)0 (expand down)0 (writable)1 (accessed)0 --> 0010b

dw 0xffff	; limit (bits 0-15)
dw 0x0		; Base (bits 0-15)
db 0x0		; Base (bits 16-23)
db 10010010b; 1st flags, type flags
db 11001111b; 2nd flags, Limit (bits 16-19)
db 0x0 		; Base(bits 24-31)

gdt_descriptor:
	; gdt 的大小，一般比实际少1
	dw gdt_end - gdt_start - 1
	
	; gdt 的开始地址
	dd gdt_start
	
; 定义一些常用的gdt段描述符的偏移地址
; 这些在保护模式中的段偏移量中时必须包含的
; 比如，当我们设置 DS= 0x10时，cpu就会知道
; 我们要使用偏移为0x10的段了，因为在我们的gdt中
; 0x10就是数据段
CODE_SEG equ gdt_code - gdt_start
DATA_SEG equ gdt_data - gdt_start
```

### 4.4 转换

一旦我们在代码中准备好了GDT和GDT描述符，我们就可以命令CPU由16-bit实模式向32-bit保护模式转换了。

正如我前面所说，实际的转换现在直接就面向代码了，但是的理解其中涉及到到步骤是很重要的。

我们需要做的第一件事，就是使用 `cli`（clear interrupt）指令禁用所有的中断，这就意味着，CPU会忽略接下来的所有可能发生的中断，知道它再次被启用。这是很重要的，因为，在分段方式中，保护模式下中断的执行与实模式下中断的执行是万确不同的，保护模式会将BIOS在内存开头加载的IVB（中断向量表）变得无效。即使CPU成功碰巧的将中断信号映射到了BIOS提供的例程，BIOS将会执行16-bit的代码，然而这在32-bit的保护模式中毫无意义，他只会通过改变他所认为的实模式下的寄存器的值来破坏CPU。

下一步就是告诉CPU我们刚刚准备好的GDT，我们使用一个简单的指令来完成这项工作：

```nasm
lgdt [gdt_descriptor]
```

现在，一切就位，我们要开始进行实际的转换了，这是通过设置CPU中一个特殊的控制寄存器 `cr0`的第一个bit位。我们不能直接设定他的值，而是应该把他加载到一个通用寄存器中，设定好值，然后再存回`cr0`中。跟我们使用 `and`来排除某些数据一致，我们使用 `or`指令来包含某些数据（没有设置cr0中其他的bit位，是因为他们已经由于一些原因被设置好了）。

```nasm
mov eax, cr0
or eax, 0x01	; 将第一位置1
mov cr0, eax
```

**在 `cr0`被更新后，CPU就进入了32-bit保护模式**。

最后一个描述其实并不完全准确，因为现代处理器都用了一个独特的技术：流水线，这允许他们并行的处理一个指令的不同阶段（我说的是单CPU，不是多CPU），以节省执行时间。比如说，每个指令都会被从内存中加载，然后被指令译码器译成微指令，然后再被执行，然后执行结果可能被存储到内存中；因为这些阶段是半可靠的，他们会在同一个CPU周期中被执行完毕，但实际上他们存在于同一个物理电路中（前一条指令在被译成微指令时，后一条指令已经在取回来的路上了。）

我们在编程的时候并不需要过多担心CPU的内部结构比如流水线，但是转换CPU的模式是一个例外，因为这其中有一个风险，那就是，CPU可能会在错误的模式中执行一些指令的不同阶段。所以，在命令CPU切换模式之后，我们需要立即强制CPU将所有流水线上的指令执行完毕，以确保我们之后的指令，都是在正确的模式下（保护模式）运行的。

如今，如果CPU知道了接下来的几条指令，流水线会工作的非常完美，因为他会对指令进行预取。这不像 `jmp` 或者`call`指令，在具体的指令被执行器，压根就不会知道下一个指令在哪里，特别是我们使用了 `jmp`和`call`后，这意味着我们跳到了另外一个段。所以在命令CPU转变模式后，我们可以立即发出一个较远的跳转指令，这将会迫使流水线刷新。

为了发出一个月城跳转指令，而不是离得很近的跳转，我们可以提供额外的目标段地址，如下所示：

```nasm
jmp <segment>:<address offset>
```

对于这个跳转，我们应该仔细考虑要跳转到哪里去。假设我们设置了一个标签比如 **start_protected_mode** ，用来标记32-bit的代码。正如我们之前讨论的，一个近的跳转，比如 `jmp start_protected_mode`可能还不足以刷新流水线，而且，我们现在正处在一个奇怪的状态，因为我们现在的代码段`cs`在保护模式就无效了。所以，我们必须将 `cd`寄存器更新我们GDT中的代码段描述符的偏移地址。因为段描述符每个都是8字节，而且我们的代码段描述符是GDT中的第二个描述符（空描述符是第一个），所以他的偏移地址为 **0x8**，这就是我们需要将代码段寄存器所设置的值。通过我们所定义的远跳转，它可以自动的将CPU的cs寄存器更新成目标段。我们可以使用之前定义好的方便的标签，让汇编器来计算那些段描述符的偏移地址，然后将他们存在 `CODE_SEG`和`DATA_SEG`中。所以我们应该这样写代码：

```nasm
jmp CODE_SEG:start_protected_mode

[bits 32]

start_protected_mode:
; 这里我们已经进入了32-bit的保护模式
...
...
```

要注意，我们没必要在物理层面上跳太远，重要的是怎么跳。

同样也要注意，我们要使用 `[bits 32]` 指令来告诉汇编器，从这里开始，就应该用32位模式的指令来编码了。再注意，这并不意味着我们不能在16-bit实模式下使用32-bit保护模式的指令，只是汇编器的指令编码会和32-bit的有所不同。事实上，当转换成保护模式以后，我们使用32-bit的寄存器 `eax`来设置控制位。

现在我们已经进入了32-bit保护模式。一旦我们进入了保护模式，一个必须要做的事情就是将所有段寄存器的值全部更新以便他们全部指向32-bit的data寄存器以及更新栈的位置。

我们可以将整个程序整合成一个可以复用的例程里：

```nasm
[bits 16]
; 转换成保护模式

switch_to_pm:
; 我们必须停用所有中断，知道我们设置好了保护模式下的 
; 中断向量，否则中断会造成破坏

cli

; 加载 GDT ，里面定义了保护模式的段
lgdt [gdt_descriptor]

; 转换模式，需要将cr0寄存器的第一位置1
mov eax, cr0
or eax, 0x1
mov cr0, eax

; 跳转来刷新流水线
jmp CODE_SEG:init_pm


[bits 32]
; 32-bit 下的程序
; 初始化保护模式下寄存器和栈
init_pm:
; 寄存器
mov ax, DATA_SEG
mov ds, ax
mov ss, ax
mov es, ax
mov fs, ax
mov gs, ax

; 栈
mov ebp, 0x90000
mov esp, ebp

call BEGIN_PM
```

### 4.5 整合

最后，我们将所有的程序整合到我们的引导程序中，来说明如何从16-bit实模式进入32-bit保护模式：

```nasm
; 一个进入32-bit保护模式的引导程序
[org 0x7c00]

; 设置栈
mov bp, 0x9000
mov sp, bp

mov bx, MSG_REAL_MOD
call print_string

; 转换到32-bit保护模式,而且永远不再回来了
call switch_to_pm
jmp $

%include "print_string.asm"
%include "gdt.asm"
%include "print_string_pm.asm"
%include "switch_to_pm.asm"

[bits 32]
; 我们转换模式后跳转到这里，并做一些初始化工作

BEGIN_PM:
	mov ebx, MSG_PROT_MODE
	; 调用32-bit的输出程序
	call print_string_pm
	
	jmp $		; 一致挂载
	
; 全局变量
MSG_REAL_MODE db "Started in 16-bit Real Mode",0
MSG_PROT_MODE db "Successfully landed in 32 Protected Mode",0

times 512-($-$$) db 0
dw 0xaa55
```

