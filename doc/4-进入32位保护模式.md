## 第四章 进入32位保护模式

对于使用已经掌握的知识在16位的实模式下操作，我们已经变得更加熟悉了，但是为了更好的利用CPU的资源，以及更好的理解CPU加架构的发展对现代操作系统有什么好处，也就是所谓硬件层面的的内存保护，我们必须要着重于32位的保护模式了。

处在32位保护模式时，主要的区别在于：

+ 寄存器被扩展到了32位，如果要完整访问一个寄存器的所有容量，需要在寄存器名称前加前缀`e`,比如 :`mov ebx, 0x2743e8fe`
+ 为了操作方便，增加了两个额外的寄存器`fs 和 gs`
+ 32位的内存地址偏移同样时可行的，所以通过偏移，可以访问巨大的 **4GB** 的内存空间（0xffffffff）
+ cpu支持一个更加成熟的，当然也相对复杂一点的内存分段方式，有两个好处：
	+ 当在一个段内编程时，可以不受到正在运行的高优先级的程序的破坏，所以你保护你的内核代码不受用户应用的破坏。
	+ CPU可以为用户程序执行虚拟内存，这样一来，像页这样的程序内存可以在硬盘和内存中透明的传输。这可以确保主存被有效利用，那些几乎不怎么使用的程序解不会占据更有用的内存资源了。
	+ 中断操作同样也变的成熟了。

从16-bit实模式向32-bit保护模式转变的过程中最难的一部分是，我们需要定义一个非常复杂的叫做 全局描述表（Global discriptor table，GDT）的数据结构，它里面定义了内存分段，以及一些保护模式的属性。我们在定义好GDT后，可以使用特定的指令把他加载到cpu中去，然后再对特殊的控制寄存器进行设置，完成实际的转换。

如果我们不需要使用汇编语言来定义GDT的话，这个工作会非常简单，但是很无奈，这种低级别转换是不可避免的，我们需要它来加载从高级语言编译好的内核指令，比如c语言，这些高级语言一般都会被编译成为32位的指令，而不是低效的16位指令。

有个还重要的事情我忘记说了：当我们转换到32位保护模式时，就已经不能再使用BIOS了。如果你认为使用BIOS调用很低级的话。这就像，退后一步，但是前进两步。

###  4.1 适应没有 BIOS 的生活