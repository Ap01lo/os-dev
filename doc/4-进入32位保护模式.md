## 第四章 进入32位保护模式

对于使用已经掌握的知识在16位的实模式下操作，我们已经变得更加熟悉了，但是为了更好的利用CPU的资源，以及更好的理解CPU加架构的发展对现代操作系统有什么好处，也就是所谓硬件层面的的内存保护，我们必须要着重于32位的保护模式了。

处在32位保护模式时，主要的区别在于：

+ 寄存器被扩展到了32位，如果要完整访问一个寄存器的所有容量，需要在寄存器名称前加前缀`e`,比如 :`mov ebx, 0x2743e8fe`
+ 为了操作方便，增加了两个额外的寄存器`fs 和 gs`
+ 32位的内存地址偏移同样时可行的，所以通过偏移，可以访问巨大的 **4GB** 的内存空间（0xffffffff）
+ CPU支持一个更加成熟的，当然也相对复杂一点的内存分段方式，有两个好处：
	+ 当在一个段内编程时，可以不受到正在运行的高优先级的程序的破坏，所以你保护你的内核代码不受用户应用的破坏。
	+ CPU可以为用户程序执行虚拟内存，这样一来，像页这样的程序内存可以在硬盘和内存中透明的传输。这可以确保主存被有效利用，那些几乎不怎么使用的程序解不会占据更有用的内存资源了。
	+ 中断操作同样也变的成熟了。

从16-bit实模式向32-bit保护模式转变的过程中最难的一部分是，我们需要定义一个非常复杂的叫做 全局描述表（Global discriptor table，GDT）的数据结构，它里面定义了内存分段，以及一些保护模式的属性。我们在定义好GDT后，可以使用特定的指令把他加载到cpu中去，然后再对特殊的控制寄存器进行设置，完成实际的转换。

如果我们不需要使用汇编语言来定义GDT的话，这个工作会非常简单，但是很无奈，这种低级别转换是不可避免的，我们需要它来加载从高级语言编译好的内核指令，比如c语言，这些高级语言一般都会被编译成为32位的指令，而不是低效的16位指令。

有个还重要的事情我忘记说了：当我们转换到32位保护模式时，就已经不能再使用BIOS了。如果你认为使用BIOS调用很低级的话。这就像，退后一步，但是前进两步。

###  4.1 适应没有 BIOS 的生活

这是真的：在我们对完全利用CPU的探索中，我们必须放弃所有那些BIOS为我们提供的有用的程序。因为我们在深入32位保护模式的时候，会发现，那些只能在16位实模式下运行的BIOS程序，在32位保护模式已经失效了；事实上，尝试使用他们，是在破坏计算机。

所以，这就意味着，32位的操作系统需要对机器上的所有硬件提供自己驱动程序（比如键盘，屏幕，硬盘，鼠标等等）。实际上，对于32位操作系统来说，短暂的切换回16位实模式然后使用BIOS是可行的，但是这种方式带来的问题远大于他的作用，起码从性能表现来看是这样的。

我们在转换模式之后遇到的第一个问题就是如何在屏幕上输出一段信息，我们先来看看再这个过程中会发生什么。之前，我们曾让BIOS在屏幕上输出字符，但是，如何做到让电脑屏幕上对应位置上的对应像素亮起呢？现在，我们需要知道，显示设备可以被配置成多种模式中的一种：文本模式以及图像模；并且，显示在屏幕上的东西，其实是特定范围的一段内存值的视觉呈现。所以，为了控制屏幕，我们需要控制当前模式下的特定内存范围。显示设备就是一个内存映射的例子，因为他就是这么工作的。

当大多数电脑启动时，当然除了那些带有高级显示器的，他们都会启动一个简单的VGA彩色文本模式，大小为 $80 \times 25$ 字符。在文本模式中，程序员不需要提供每个字符精确的像素信息，因为在VGA显示设备的主控内存中，已经定义好了每个字符。屏幕上的每个字符都用2个字节来表示，第一个字节是字符的ASCII码，第二个字节是字符的属性，比如前景色，背景色，是否需要闪烁等。

所以，如果我们想要在屏幕上输出字符，就需要在当前的VGA模式下，在对应的内存处设置ASCII码以及属性，这个内存地址通常是`0xb8000`。如果我们简单的改改我们在16位实模式下的 `print_string`代码，就可以得到一个不需要使用BIOS中断程序的32位的保护模式代码，可以直接向显示器的内存处写入数据，如图4.1所示。

```nasm
; 图 4.1

[bits 32]

VIDEO_MEMORY equ 0xb8000
WHTIE_ON_BLACK equ 0x0f

print_string_pm:
	pusha
	mov edx, VIDEO_MEMORY
	
print_string_pm_loop:
	mov al, [ebx]
	mov ah, WHITE_ON_BLACK
	
	cmp al, 0
	je print_string_pm_done
	
	mov [edx], ax
	
	add ebx, 1
	add edx, 2
	
	jmp print_string_pm_loop
	
print_string_pm_done:
	popa
	ret
```

这段代码通常情况下，会在屏幕的左上角输出字符，所以会覆写先前的数据，而不是向下接着写。我们需要花时间在这个汇编代码上增加更复杂的功能，但是也别太着急，在我们掌握了保护模式之后，我们就可以使用高级语言来编写代码，可以更轻松的实现这些功能。

### 4.2 理解全局描述符表（GDT）



